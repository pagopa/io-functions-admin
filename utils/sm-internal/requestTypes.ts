/* eslint-disable @typescript-eslint/explicit-function-return-type */
/* eslint-disable prefer-arrow/prefer-arrow-functions */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable functional/prefer-readonly-type */
/* eslint-disable @typescript-eslint/consistent-type-definitions */
/* eslint-disable sonarjs/no-duplicate-string */
/* eslint-disable spaced-comment */
/* eslint-disable @typescript-eslint/dot-notation */
// DO NOT EDIT THIS FILE
// This file has been generated by gen-api-models
// eslint-disable sonar/max-union-size
// eslint-disable sonarjs/no-identical-functions

import * as t from "io-ts";

import * as r from "@pagopa/ts-commons/lib/requests";

import { ApplicationInfo } from "./ApplicationInfo";

import { ProblemJson } from "./ProblemJson";

import { UserSessionInfo } from "./UserSessionInfo";

import { AuthLockBody } from "./AuthLockBody";

import { SuccessResponse } from "./SuccessResponse";

import { AuthUnlockBody } from "./AuthUnlockBody";

import { SessionState } from "./SessionState";

/****************************************************************
 * info
 */

// Request type definition
export type InfoT = r.IGetApiRequestType<
  { readonly ApiKeyAuth: string },
  "X-Functions-Key",
  never,
  | r.IResponseType<200, ApplicationInfo, never>
  | r.IResponseType<500, ProblemJson, never>
>;

export const infoDefaultResponses = {
  200: ApplicationInfo,
  500: ProblemJson
};

export type InfoResponsesT<
  A0 = ApplicationInfo,
  C0 = ApplicationInfo,
  A1 = ProblemJson,
  C1 = ProblemJson
> = {
  200: t.Type<A0, C0>;
  500: t.Type<A1, C1>;
};

export function infoDecoder<
  A0 = ApplicationInfo,
  C0 = ApplicationInfo,
  A1 = ProblemJson,
  C1 = ProblemJson
>(
  overrideTypes:
    | Partial<InfoResponsesT<A0, C0, A1, C1>>
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  r.IResponseType<200, A0, never> | r.IResponseType<500, A1, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((infoDefaultResponses as unknown) as InfoResponsesT<A0, C0, A1, C1>),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A1, never>>;

  return r.composeResponseDecoders(d200, d500);
}

// Decodes the success response with the type defined in the specs
export const infoDefaultDecoder = () => infoDecoder();

/****************************************************************
 * getSession
 */

// Request type definition
export type GetSessionT = r.IGetApiRequestType<
  {
    readonly ApiKeyAuth: string;
    readonly fiscalCode: string;
    readonly token?: string;
  },
  "X-Functions-Key",
  never,
  | r.IResponseType<200, UserSessionInfo, never>
  | r.IResponseType<400, undefined, never>
  | r.IResponseType<401, undefined, never>
  | r.IResponseType<404, undefined, never>
  | r.IResponseType<429, undefined, never>
  | r.IResponseType<500, ProblemJson, never>
>;

export const getSessionDefaultResponses = {
  200: UserSessionInfo,
  400: t.undefined,
  401: t.undefined,
  404: t.undefined,
  429: t.undefined,
  500: ProblemJson
};

export type GetSessionResponsesT<
  A0 = UserSessionInfo,
  C0 = UserSessionInfo,
  A1 = undefined,
  C1 = undefined,
  A2 = undefined,
  C2 = undefined,
  A3 = undefined,
  C3 = undefined,
  A4 = undefined,
  C4 = undefined,
  A5 = ProblemJson,
  C5 = ProblemJson
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  404: t.Type<A3, C3>;
  429: t.Type<A4, C4>;
  500: t.Type<A5, C5>;
};

export function getSessionDecoder<
  A0 = UserSessionInfo,
  C0 = UserSessionInfo,
  A1 = undefined,
  C1 = undefined,
  A2 = undefined,
  C2 = undefined,
  A3 = undefined,
  C3 = undefined,
  A4 = undefined,
  C4 = undefined,
  A5 = ProblemJson,
  C5 = ProblemJson
>(
  overrideTypes:
    | Partial<
        GetSessionResponsesT<A0, C0, A1, C1, A2, C2, A3, C3, A4, C4, A5, C5>
      >
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<404, A3, never>
  | r.IResponseType<429, A4, never>
  | r.IResponseType<500, A5, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getSessionDefaultResponses as unknown) as GetSessionResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4,
      A5,
      C5
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;

  const d429 = (type[429].name === "undefined"
    ? r.constantResponseDecoder<undefined, 429, never>(429, undefined)
    : r.ioResponseDecoder<
        429,
        typeof type[429]["_A"],
        typeof type[429]["_O"],
        never
      >(429, type[429])) as r.ResponseDecoder<r.IResponseType<429, A4, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A5, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(
        r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
        d404
      ),
      d429
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const getSessionDefaultDecoder = () => getSessionDecoder();

/****************************************************************
 * authLock
 */

// Request type definition
export type AuthLockT = r.IPostApiRequestType<
  {
    readonly ApiKeyAuth: string;
    readonly fiscalCode: string;
    readonly token?: string;
    readonly body: AuthLockBody | ReadableStream<Uint8Array> | Buffer;
  },
  "Content-Type" | "X-Functions-Key",
  never,
  | r.IResponseType<204, undefined, never>
  | r.IResponseType<400, ProblemJson, never>
  | r.IResponseType<401, ProblemJson, never>
  | r.IResponseType<409, ProblemJson, never>
  | r.IResponseType<500, ProblemJson, never>
>;

export const authLockDefaultResponses = {
  204: t.undefined,
  400: ProblemJson,
  401: ProblemJson,
  409: ProblemJson,
  500: ProblemJson
};

export type AuthLockResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = ProblemJson,
  C1 = ProblemJson,
  A2 = ProblemJson,
  C2 = ProblemJson,
  A3 = ProblemJson,
  C3 = ProblemJson,
  A4 = ProblemJson,
  C4 = ProblemJson
> = {
  204: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  409: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function authLockDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = ProblemJson,
  C1 = ProblemJson,
  A2 = ProblemJson,
  C2 = ProblemJson,
  A3 = ProblemJson,
  C3 = ProblemJson,
  A4 = ProblemJson,
  C4 = ProblemJson
>(
  overrideTypes:
    | Partial<AuthLockResponsesT<A0, C0, A1, C1, A2, C2, A3, C3, A4, C4>>
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<204, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<409, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((authLockDefaultResponses as unknown) as AuthLockResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 204: overrideTypes } : overrideTypes)
  };

  const d204 = (type[204].name === "undefined"
    ? r.constantResponseDecoder<undefined, 204, never>(204, undefined)
    : r.ioResponseDecoder<
        204,
        typeof type[204]["_A"],
        typeof type[204]["_O"],
        never
      >(204, type[204])) as r.ResponseDecoder<r.IResponseType<204, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d409 = (type[409].name === "undefined"
    ? r.constantResponseDecoder<undefined, 409, never>(409, undefined)
    : r.ioResponseDecoder<
        409,
        typeof type[409]["_A"],
        typeof type[409]["_O"],
        never
      >(409, type[409])) as r.ResponseDecoder<r.IResponseType<409, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d204, d400), d401),
      d409
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const authLockDefaultDecoder = () => authLockDecoder();

/****************************************************************
 * lockUserSession
 */

// Request type definition
export type LockUserSessionT = r.IPostApiRequestType<
  {
    readonly ApiKeyAuth: string;
    readonly fiscalCode: string;
    readonly token?: string;
  },
  "Content-Type" | "X-Functions-Key",
  never,
  | r.IResponseType<200, SuccessResponse, never>
  | r.IResponseType<400, undefined, never>
  | r.IResponseType<401, undefined, never>
  | r.IResponseType<404, undefined, never>
  | r.IResponseType<500, ProblemJson, never>
>;

export const lockUserSessionDefaultResponses = {
  200: SuccessResponse,
  400: t.undefined,
  401: t.undefined,
  404: t.undefined,
  500: ProblemJson
};

export type LockUserSessionResponsesT<
  A0 = SuccessResponse,
  C0 = SuccessResponse,
  A1 = undefined,
  C1 = undefined,
  A2 = undefined,
  C2 = undefined,
  A3 = undefined,
  C3 = undefined,
  A4 = ProblemJson,
  C4 = ProblemJson
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  404: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function lockUserSessionDecoder<
  A0 = SuccessResponse,
  C0 = SuccessResponse,
  A1 = undefined,
  C1 = undefined,
  A2 = undefined,
  C2 = undefined,
  A3 = undefined,
  C3 = undefined,
  A4 = ProblemJson,
  C4 = ProblemJson
>(
  overrideTypes:
    | Partial<LockUserSessionResponsesT<A0, C0, A1, C1, A2, C2, A3, C3, A4, C4>>
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<404, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((lockUserSessionDefaultResponses as unknown) as LockUserSessionResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d404 = (type[404].name === "undefined"
    ? r.constantResponseDecoder<undefined, 404, never>(404, undefined)
    : r.ioResponseDecoder<
        404,
        typeof type[404]["_A"],
        typeof type[404]["_O"],
        never
      >(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
      d404
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const lockUserSessionDefaultDecoder = () => lockUserSessionDecoder();

/****************************************************************
 * unlockUserSession
 */

// Request type definition
export type UnlockUserSessionT = r.IDeleteApiRequestType<
  {
    readonly ApiKeyAuth: string;
    readonly fiscalCode: string;
    readonly token?: string;
  },
  "X-Functions-Key",
  never,
  | r.IResponseType<200, SuccessResponse, never>
  | r.IResponseType<400, undefined, never>
  | r.IResponseType<401, undefined, never>
  | r.IResponseType<500, ProblemJson, never>
>;

export const unlockUserSessionDefaultResponses = {
  200: SuccessResponse,
  400: t.undefined,
  401: t.undefined,
  500: ProblemJson
};

export type UnlockUserSessionResponsesT<
  A0 = SuccessResponse,
  C0 = SuccessResponse,
  A1 = undefined,
  C1 = undefined,
  A2 = undefined,
  C2 = undefined,
  A3 = ProblemJson,
  C3 = ProblemJson
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  500: t.Type<A3, C3>;
};

export function unlockUserSessionDecoder<
  A0 = SuccessResponse,
  C0 = SuccessResponse,
  A1 = undefined,
  C1 = undefined,
  A2 = undefined,
  C2 = undefined,
  A3 = ProblemJson,
  C3 = ProblemJson
>(
  overrideTypes:
    | Partial<UnlockUserSessionResponsesT<A0, C0, A1, C1, A2, C2, A3, C3>>
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<500, A3, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((unlockUserSessionDefaultResponses as unknown) as UnlockUserSessionResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A3, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const unlockUserSessionDefaultDecoder = () => unlockUserSessionDecoder();

/****************************************************************
 * releaseAuthLock
 */

// Request type definition
export type ReleaseAuthLockT = r.IPostApiRequestType<
  {
    readonly ApiKeyAuth: string;
    readonly fiscalCode: string;
    readonly token?: string;
    readonly body: AuthUnlockBody | ReadableStream<Uint8Array> | Buffer;
  },
  "Content-Type" | "X-Functions-Key",
  never,
  | r.IResponseType<204, undefined, never>
  | r.IResponseType<400, ProblemJson, never>
  | r.IResponseType<401, ProblemJson, never>
  | r.IResponseType<403, undefined, never>
  | r.IResponseType<500, ProblemJson, never>
>;

export const releaseAuthLockDefaultResponses = {
  204: t.undefined,
  400: ProblemJson,
  401: ProblemJson,
  403: t.undefined,
  500: ProblemJson
};

export type ReleaseAuthLockResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = ProblemJson,
  C1 = ProblemJson,
  A2 = ProblemJson,
  C2 = ProblemJson,
  A3 = undefined,
  C3 = undefined,
  A4 = ProblemJson,
  C4 = ProblemJson
> = {
  204: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  403: t.Type<A3, C3>;
  500: t.Type<A4, C4>;
};

export function releaseAuthLockDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = ProblemJson,
  C1 = ProblemJson,
  A2 = ProblemJson,
  C2 = ProblemJson,
  A3 = undefined,
  C3 = undefined,
  A4 = ProblemJson,
  C4 = ProblemJson
>(
  overrideTypes:
    | Partial<ReleaseAuthLockResponsesT<A0, C0, A1, C1, A2, C2, A3, C3, A4, C4>>
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<204, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<403, A3, never>
  | r.IResponseType<500, A4, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((releaseAuthLockDefaultResponses as unknown) as ReleaseAuthLockResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3,
      A4,
      C4
    >),
    ...(isDecoder(overrideTypes) ? { 204: overrideTypes } : overrideTypes)
  };

  const d204 = (type[204].name === "undefined"
    ? r.constantResponseDecoder<undefined, 204, never>(204, undefined)
    : r.ioResponseDecoder<
        204,
        typeof type[204]["_A"],
        typeof type[204]["_O"],
        never
      >(204, type[204])) as r.ResponseDecoder<r.IResponseType<204, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d403 = (type[403].name === "undefined"
    ? r.constantResponseDecoder<undefined, 403, never>(403, undefined)
    : r.ioResponseDecoder<
        403,
        typeof type[403]["_A"],
        typeof type[403]["_O"],
        never
      >(403, type[403])) as r.ResponseDecoder<r.IResponseType<403, A3, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A4, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(
      r.composeResponseDecoders(r.composeResponseDecoders(d204, d400), d401),
      d403
    ),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const releaseAuthLockDefaultDecoder = () => releaseAuthLockDecoder();

/****************************************************************
 * deleteUserSession
 */

// Request type definition
export type DeleteUserSessionT = r.IPostApiRequestType<
  {
    readonly ApiKeyAuth: string;
    readonly fiscalCode: string;
    readonly token?: string;
  },
  "Content-Type" | "X-Functions-Key",
  never,
  | r.IResponseType<200, SuccessResponse, never>
  | r.IResponseType<400, undefined, never>
  | r.IResponseType<401, undefined, never>
  | r.IResponseType<500, ProblemJson, never>
>;

export const deleteUserSessionDefaultResponses = {
  200: SuccessResponse,
  400: t.undefined,
  401: t.undefined,
  500: ProblemJson
};

export type DeleteUserSessionResponsesT<
  A0 = SuccessResponse,
  C0 = SuccessResponse,
  A1 = undefined,
  C1 = undefined,
  A2 = undefined,
  C2 = undefined,
  A3 = ProblemJson,
  C3 = ProblemJson
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  500: t.Type<A3, C3>;
};

export function deleteUserSessionDecoder<
  A0 = SuccessResponse,
  C0 = SuccessResponse,
  A1 = undefined,
  C1 = undefined,
  A2 = undefined,
  C2 = undefined,
  A3 = ProblemJson,
  C3 = ProblemJson
>(
  overrideTypes:
    | Partial<DeleteUserSessionResponsesT<A0, C0, A1, C1, A2, C2, A3, C3>>
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<500, A3, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((deleteUserSessionDefaultResponses as unknown) as DeleteUserSessionResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A3, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const deleteUserSessionDefaultDecoder = () => deleteUserSessionDecoder();

/****************************************************************
 * getUserSessionState
 */

// Request type definition
export type GetUserSessionStateT = r.IGetApiRequestType<
  {
    readonly ApiKeyAuth: string;
    readonly fiscalCode: string;
    readonly token?: string;
  },
  "X-Functions-Key",
  never,
  | r.IResponseType<200, SessionState, never>
  | r.IResponseType<400, undefined, never>
  | r.IResponseType<401, undefined, never>
  | r.IResponseType<500, ProblemJson, never>
>;

export const getUserSessionStateDefaultResponses = {
  200: SessionState,
  400: t.undefined,
  401: t.undefined,
  500: ProblemJson
};

export type GetUserSessionStateResponsesT<
  A0 = SessionState,
  C0 = SessionState,
  A1 = undefined,
  C1 = undefined,
  A2 = undefined,
  C2 = undefined,
  A3 = ProblemJson,
  C3 = ProblemJson
> = {
  200: t.Type<A0, C0>;
  400: t.Type<A1, C1>;
  401: t.Type<A2, C2>;
  500: t.Type<A3, C3>;
};

export function getUserSessionStateDecoder<
  A0 = SessionState,
  C0 = SessionState,
  A1 = undefined,
  C1 = undefined,
  A2 = undefined,
  C2 = undefined,
  A3 = ProblemJson,
  C3 = ProblemJson
>(
  overrideTypes:
    | Partial<GetUserSessionStateResponsesT<A0, C0, A1, C1, A2, C2, A3, C3>>
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  | r.IResponseType<200, A0, never>
  | r.IResponseType<400, A1, never>
  | r.IResponseType<401, A2, never>
  | r.IResponseType<500, A3, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d["_A"] !== "undefined";

  const type = {
    ...((getUserSessionStateDefaultResponses as unknown) as GetUserSessionStateResponsesT<
      A0,
      C0,
      A1,
      C1,
      A2,
      C2,
      A3,
      C3
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === "undefined"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200]["_A"],
        typeof type[200]["_O"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d400 = (type[400].name === "undefined"
    ? r.constantResponseDecoder<undefined, 400, never>(400, undefined)
    : r.ioResponseDecoder<
        400,
        typeof type[400]["_A"],
        typeof type[400]["_O"],
        never
      >(400, type[400])) as r.ResponseDecoder<r.IResponseType<400, A1, never>>;

  const d401 = (type[401].name === "undefined"
    ? r.constantResponseDecoder<undefined, 401, never>(401, undefined)
    : r.ioResponseDecoder<
        401,
        typeof type[401]["_A"],
        typeof type[401]["_O"],
        never
      >(401, type[401])) as r.ResponseDecoder<r.IResponseType<401, A2, never>>;

  const d500 = (type[500].name === "undefined"
    ? r.constantResponseDecoder<undefined, 500, never>(500, undefined)
    : r.ioResponseDecoder<
        500,
        typeof type[500]["_A"],
        typeof type[500]["_O"],
        never
      >(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A3, never>>;

  return r.composeResponseDecoders(
    r.composeResponseDecoders(r.composeResponseDecoders(d200, d400), d401),
    d500
  );
}

// Decodes the success response with the type defined in the specs
export const getUserSessionStateDefaultDecoder = () =>
  getUserSessionStateDecoder();
